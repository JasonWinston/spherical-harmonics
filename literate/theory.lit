@code_type c .c

@s Introduction

In realtime computer graphics, objects are usually lit by both diffuse and ambient lighting. The diffuse lighting simulates the direct radiance from nearby lights, while the ambient simulates light bounced from the surrounding scene. Since computing bounced lighting is usually too slow for realtime rendering an approximation method must be used, with the most basic being a constant color (usually a dark gray) added to the diffuse light.

![diffuse term](img/teapot_diffuse.png)
![ambient term](img/teapot_ambient.png)
![combined](img/teapot_combined.png)

Rendering algorithms which simulate some form of light bouncing from the scene are called [global illumination](https://en.wikipedia.org/wiki/Global_illumination) methods. In this paper I will explain how to implement a fast global illumination method using a mathematical tool called **spherical harmonics**. Spherical harmonics are a special set of functions that will be used to store a more complex ambient lighting signal with only 9 floats per color channel. The bounced lighting signal will the be recreated approximately in a vertex or fragment shader, using only these 9 floats.

This method was originally described by Ramaoorthi. [2] This paper is a more in depth explanation of his work.

@s Background

Global illumination is often implemented by rendering environment maps which capture light reflected from the scene.

Typically reflection probes are placed throughout the scene. At each probe, images of the surrounding enviornment are rendered to create a cubemap. At runtime, other scene objects search for the nearest probes and use its cubemaps to calculate reflections and ambient lighting.

Unfortuantly, cubemaps require a significant amount of memory. A very low resolution RGB cubemap uses $64\times64\times6\times3\approx73kb$ and a high resolution RGB cubemap uses $1024\times1024\times6\times3\approx18mb$! Even though smooth reflections, such as glass or mirrors, require such high resolution, most enviornmental lighting is low frequency, meaning changes between shades are gradual.

Since ambient light is low frequency, we can aim for a rough approximation of the overall signal, instead of crisp images. Valve's source engine accomplishes this by averaging the cubemap to a single color for each face. [1] Each of these colors is passed to the vertex shader and the surface normal is used to interpolate between values.

Valve's Ambient Cube is effecient and provides a richer ambient than a constant term, but only provides a rough approximation of ambient lighting. To store more complex ambient lighting we can use **spherical harmonics**. As we will explore, a good spherical harmonic approximation requires only 9 coeffecients to be stored, and is much richer than Valve's Ambient Cube.

These images from Valve's paper compare these three methods:

![enviornment map](img/ball_env.jpg)
![valve ambient cube](img/ball_cube.jpg)
![valve ambient cube](img/ball_sh.jpg)

@s Overview

1. Render a cubemap of the surrounding scene.
I will assume that this step is taken care of. Usually cubemaps are rendered offline, or when the scnee is loaded.
2. Calculate spherical harmonic coeffecients from the cubemap.

3. 

@s Spherical Harmonics

What are spherical harmonics?

**Definition:** Laplace's equation states that the divergence of the gradient of a function is 0. It can be written as: $$\nabla\cdot\nabla f=0$$.

In three variables Laplace's equation can be written as:

$$\frac{\partial^{2}}{\partial x^{2}}+\frac{\partial^{2}}{\partial y^{2}}+\frac{\partial^{2}}{\partial z^{2}}=0$$

**Definition:** Equations which satisfy Laplace's equation are called **harmonics**. [3]

Our objective will be to find equations which are defined on the sphere, which satisfy laplace's equation.

Laplace's equation in spherical coordinates can be written as:

$$\frac{\partial^{2}}{\partial r^{2}}+\frac{2}{r}\frac{\partial}{\partial r} + \frac{1}{r^{2}\sin^{2}(\phi)}\frac{\partial^{2}}{\partial \theta^{2}}+\frac{1}{r^{2}}\frac{\partial^{2}}{\partial \phi^{2}}+\frac{\cot(\phi)}{r^{2}}\frac{\partial}{\partial \phi}=0$$

Here is what some of these solutions look like:

![spherical harmonics](img/sh.jpg)

You may recognize these from chemistry. There spherical harmonics also describe the probablity functions of [Atomic Orbitals](https://en.wikipedia.org/wiki/Atomic_orbital).

The big idea is that we can take any function on a sphere (such as a light signal) and approximate it using sphereical harmonics. We simply calculate how much each term contributes to the overall signal and save those coeffecients. To recreate the signal we add up individual terms multiplied by the weighting coeffecients. This idea is very similar to fourier series in two dimensions.

How do we calculate how much each term contributes? The inner product gives us the component of a vector along another vector. 

let $l(x)$ be the function on the sphere and $h(x)$ be the spherical harmonic, and $S$ be the sphere surface.

$$ \int_{S} h(x)l(x) dv$$

For computational purposes we will do a discrete integral.

$$ \frac{1}{N} \sum_{i=0}^{N} h(x_{i})l(x_{i}) $$

@s Cubemap Approximation

The following structure stores the 9 spherical harmonics coeffecients for each of the red, green, and blue color channels. The total number of coeffecients is 27.

This function calculates one of the first 9 spherical harmonics at a particular point on the unit sphere. Even though they are derived from a complex formula, then end results are very simple calculations. The most complex is the 9th harmonic which is only a quadratic computation. A table of spherical harmonics can be found [https://en.wikipedia.org/wiki/Table_of_spherical_harmonics](https://en.wikipedia.org/wiki/Table_of_spherical_harmonics).

--- spherical harmonics
static inline double sh_eval_9(int i, double x, double y, double z)
{
    switch (i)
    {
        case 0:
            return 0.5 * sqrt(1.0 / M_PI);
        case 1:
            return x * 0.5 * sqrt(3.0 / M_PI);
        case 2:
            return z * 0.5 * sqrt(3.0 / M_PI);
        case 3:
            return y * 0.5 * sqrt(3.0 / M_PI);
        case 4:
            return x * z * 0.5 * sqrt(15.0 / M_PI);
        case 5:
            return y * z * 0.5 * sqrt(15.0 / M_PI);
        case 6:
            return x * y * 0.5 * sqrt(15.0 / M_PI);
        case 7:
            return (3.0 * z*z - 1.0) * 0.25 * sqrt(5.0 / M_PI);
        case 8:
            return (x*x - y*y) * 0.25 * sqrt(15.0 / M_PI);
        default:
            assert(0);
            return 0;
    }
}
--- 

For each spherical harmonic we need to calculute a coeffecient which describes how much a particular harmonic function contributes to the overall light signal. Each coeffecient is found by calculating the inner product of each function and the harmonic function.

This calculation is a surface integral over the unit sphere of the product of the light signal and the harmonic function.

$$ \int_{S} h(x)l(x) dv$$

To calculate this integral we will use a discrete summation which approximates the analytic integral. This also makes sense because the cubemap is a discrete signal as well. There are only a finite number of pixels to include.

$$ \frac{1}{N} \sum_{i=0}^{N} h(x_{i})l(x_{i}) $$

In this formula $N$, the total number of pieces to sum, is the number of pixels on the cubemap.

$$N=6w^{2}h^{2}$$

--- integrate cubemap

void sh_integrate_cubemap(const unsigned char** face_data,
                          unsigned int width,
                          unsigned int height,
                          unsigned int components_per_pixel,
                          ShChannel* out_channels)
{
    // zero out coeffecients for accumulation
    for (int comp = 0; comp < components_per_pixel; ++comp)
    {
        for (int s = 0; s < SH_COUNT; ++s)
            out_channels[comp].coeffs[s] = 0.0;
    }

    for (int face = 0; face < CUBE_FACE_COUNT; ++face)
    {
        for (int y = 0; y < height; ++y)
        {
            for (int x = 0; x < width; ++x)
            {
                // center each pixel
                double px = (double)x + 0.5;
                double py = (double)y + 0.5;
                // normalize into [-1, 1] range
                double u = 2.0 * (px / (double)width) - 1.0;
                double v = 2.0 * (py / (double)height) - 1.0;

                // calculate the solid angle
                double d_x = 1.0 / (double)width;
                double x0 = u - d_x;
                double y0 = v - d_x;
                double x1 = u + d_x;
                double y1 = v + d_x;
                double d_a = surface_area(x0, y0) - surface_area(x0, y1) - surface_area(x1, y0) + surface_area(x1, y1);

                // find vector on unit sphere
                double dir[3];
                uv_to_cube(u, v, face, dir);
                normalize(dir, 3);
  
                size_t pixel_start = (x + y * width) * components_per_pixel;

                for (int s = 0; s < SH_COUNT; ++s)
                {
                    double sh_val = sh_eval_9(s, dir[0], dir[1], dir[2]);

                    for (int comp = 0; comp < components_per_pixel; ++comp)
                    {
                        double col = face_data[face][pixel_start + comp] / 255.0;
                        out_channels[comp].coeffs[s] += col * sh_val * d_a;
                    }
                }
           }
        }
    }
}


---

--- solid angle
static double surface_area(double x, double y)
{
    return atan2(x * y, sqrt(x * x + y * y + 1.0));
}

---

--- channel struct
#define SH_COUNT 9

typedef struct
{
    double coeffs[SH_COUNT];
} ShChannel;
---


--- sample shader
float sh9(mat3 coef, vec3 n)
{
    float sum = coef[0][0] * 0.282095
    + coef[1][0] * 0.488603 * n.x
    + coef[2][0] * 0.488603 * n.z
    + coef[0][1] * 0.488603 * n.y
    + coef[1][1] * 1.092548 * n.x * n.z
    + coef[2][1] * 1.092548 * n.y * n.z
    + coef[0][2] * 1.092548 * n.x * n.y
    + coef[1][2] * 0.315391 * (3.0 * n.z*n.z - 1.0)
    + coef[2][2] * 0.546274 * (n.x*n.x - n.y*n.y);
    return sum;
}

... 

vec3 ambient = vec3(sh9(red_coeff, n), sh9(green_coeff, n), sh9(blue_coeff, n)); 
---

@s Utilties

This function transforms a uv coordinate, the index of a cube face to a point on the unit cube.

--- transform uv to cube
static inline void uv_to_cube(double u, double v, int face, double* out_dir)
{
    switch (face)
    {
        case CUBE_FACE_RIGHT:
            out_dir[0] = 1.0f;
            out_dir[1] = v;
            out_dir[2] = -u;
            break;
        case CUBE_FACE_LEFT:
            out_dir[0] = -1.0f;
            out_dir[1] = v;
            out_dir[2] = u;
            break;
        case CUBE_FACE_TOP:
            out_dir[0] = u;
            out_dir[1] = 1.0f;
            out_dir[2] = -v; 
            break;
        case CUBE_FACE_BOTTOM:
            out_dir[0] = u;
            out_dir[1] = -1.0f;
            out_dir[2] = v;
            break;
        case CUBE_FACE_BACK: 
            out_dir[0] = u;
            out_dir[1] = v;
            out_dir[2] = 1.0f;
            break;
        case CUBE_FACE_FRONT:
            out_dir[0] = -u;
            out_dir[1] = v;
            out_dir[2] = -1.0f;
            break;
    }
}
---

--- normalize vector
static inline void normalize(double* dir, int n)
{
    double length_sqr = 0.0f;
    for (int i = 0; i < n; ++i)
        length_sqr += dir[i] * dir[i];

    double scale = 1.0 / sqrt(length_sqr);
    for (int i = 0; i < n; ++i)
        dir[i] *= scale;
}
---

--- sh9.h --- noWeave

#ifndef SH_9_H
#define SH_9_H

#include <math.h>
#include <assert.h>
/*

SAMPLE SHADER

Here is a sample shader function for evaluting the spherical harmonics. The functions are the same as in this header, but in numerical form. The 9 coeffecients for each color are stored in a 3x3 matrix.

@{sample shader]

*/


@{channel struct}
@{spherical harmonics}

void sh_integrate_cubemap(const unsigned char** face_data,
                          unsigned int width,
                          unsigned int height,
                          unsigned int components_per_pixel,
                          ShChannel* out_channels);

#endif
---

--- sh9.c --- noWeave
#include "sh9.h"
#include <stdlib.h>
#include <stdio.h>
#include "texture.h"

@{normalize vector}
@{transform uv to cube}

@{solid angle}
@{integrate cubemap}
---


@s References


1. [Shading in Valve's Source Engine](http://www.valvesoftware.com/publications/2006/SIGGRAPH06_Course_ShadingInValvesSourceEngine.pdf)
2. [An Effecient Representation for Irradiance Environment Maps](https://graphics.stanford.edu/papers/envmap/)
3. [MathWorld Laplace's Equation](http://mathworld.wolfram.com/LaplacesEquation.html)
4. Linearity, Symmetry, And Prediction In The Hydrogen Atom


