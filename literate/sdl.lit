@code_type c .c


@s Scene 

--- scene struct
typedef struct
{
    Vec3 eye;
    Vec3 target;
    Mat4 eye_rotation;

    Mesh demo;
    Texture cube;

    GLuint object_prog;
    GLuint object_vert;
    GLuint object_frag;
} Scene;
---


@s Renderer

--- render functions --- noWeave
void render_init();
void render_frame(int mouse_dx, int mouse_dy);
---

--- render setup
void render_init()
{
    glEnable(GL_DEPTH_TEST);

    scene.eye = vec3_create(0.0f, 1.0f, -2.0f);
    scene.target = vec3_create(0.0f, 1.0f, 0.0f);
    scene.eye_rotation = mat4_create_identity();

    scene.demo = mesh_load("data/astronaut.stl");
    upload_mesh(&scene.demo);

    const char* paths[] = {"data/cube1/posx.jpg",
                           "data/cube1/negx.jpg",
                           "data/cube1/posy.jpg",
                           "data/cube1/negy.jpg",
                           "data/cube1/posz.jpg",
                           "data/cube1/negz.jpg"};

    scene.cube = cubemap_load(paths);
    upload_cubemap(&scene.cube);
                             
    scene.object_vert = compile_shader(GL_VERTEX_SHADER, vert_shader_source, 1);
    scene.object_frag = compile_shader(GL_FRAGMENT_SHADER, frag_shader_source, 1);
    scene.object_prog = glCreateProgram();

    glAttachShader(scene.object_prog, scene.object_vert);
    glAttachShader(scene.object_prog, scene.object_frag);

    glBindAttribLocation(scene.object_prog, ATTRIB_VERTEX, "a_vertex");
    glBindAttribLocation(scene.object_prog, ATTRIB_NORMAL, "a_normal");
    glLinkProgram(scene.object_prog);
}

---

--- render a frame

void render_frame(int mouse_dx, int mouse_dy)
{
    Mat4 x_rot = mat4_create_rotate(mouse_dx / 100.0f, vec3_create(0.0f, 1.0f, 0.0f));
    Mat4 y_rot = mat4_create_rotate(mouse_dy / 100.0f, vec3_create(1.0f, 0.0f, 0.0f));

    Mat4 combined;
    mat4_mult(&x_rot, &y_rot, &combined);
    mat4_mult(&combined, &scene.eye_rotation, &scene.eye_rotation);

    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);

    Mat4 proj = mat4_create_perspective(60.0f, 1.44f, 1.0f, 20.0f);
    Mat4 view = mat4_create_look(mat4_mult_vec3(&scene.eye_rotation, scene.eye), scene.target, vec3_create(0.0f, 1.0f, 0.0));

    glUseProgram(scene.object_prog);
    glUniform1i(glGetUniformLocation(scene.object_prog, "u_cube"), 0);
    glUniformMatrix4fv(glGetUniformLocation(scene.object_prog, "u_proj"), 1, GL_FALSE, proj.m);
    glUniformMatrix4fv(glGetUniformLocation(scene.object_prog, "u_view"), 1, GL_FALSE, view.m);

    glBindTexture(GL_TEXTURE_CUBE_MAP, scene.cube.pbo); 
    glBindVertexArray(scene.demo.vao);
    glDrawArrays(GL_TRIANGLES, 0, scene.demo.vertex_count);
    
    for (GLenum err; (err = glGetError()) != GL_NO_ERROR;)
        printf("%x\n", err); 
}

---

@s Shaders

--- vertex shader
const char* vert_shader_source = " \
#version 100\n\
uniform mat4 u_view; \
uniform mat4 u_proj; \
attribute vec4 a_vertex; \
attribute vec3 a_normal; \
varying mediump vec3 v_normal; \
\
void main() \
{ \
v_normal = a_normal; \
gl_Position = u_proj * u_view * a_vertex; \
}";
---

--- fragment shader
const char* frag_shader_source = " \
#version 100\n\
uniform samplerCube u_cube;\n\
varying mediump vec3 v_normal;\n\
void main() \
{ \
gl_FragColor = vec4(v_normal.y * 0.488603, 0.0, 0.0, 1.0); \
}";

---

@s OpenGL Utilities

--- compile shaders
static GLuint compile_shader(GLint shaderType, const char* shaderSource, int debug)
{
    GLuint shader = glCreateShader(shaderType);

    const char* sources[] = { shaderSource };
    glShaderSource(shader, 1, sources, NULL);
    glCompileShader(shader);

    if (debug)
    {
        GLint logLength;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);

        if (logLength > 0)
        {
            GLchar *log = (GLchar *)malloc(logLength);
            glGetShaderInfoLog(shader, logLength, &logLength, log);
            printf("%s\n", log);
        }
    }

    return shader;
}
---


--- upload meshes
enum
{
    ATTRIB_VERTEX = 0,
    ATTRIB_NORMAL,
};

static void upload_mesh(Mesh* mesh)
{
    GLuint vao, vbo;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    glGenBuffers(1, &vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    
    glBufferData(GL_ARRAY_BUFFER, sizeof(MeshVert) * mesh->vertex_count, mesh->vertices, GL_STATIC_DRAW);
 
    glEnableVertexAttribArray(ATTRIB_VERTEX);
    glVertexAttribPointer(ATTRIB_VERTEX, 3, GL_FLOAT, GL_FALSE, sizeof(MeshVert), NULL);

    glEnableVertexAttribArray(ATTRIB_NORMAL);
    glVertexAttribPointer(ATTRIB_NORMAL, 3, GL_FLOAT, GL_FALSE, sizeof(MeshVert), (char*)NULL + sizeof(Vec3));     

    mesh->vao = vao;
    mesh->vbo = vbo;
}
---


--- upload cubemaps
static void upload_cubemap(Texture* texture)
{
    GLenum internalFormat = GL_RGB;
    GLenum format = GL_RGB;

    GLuint tex;
    glGenTextures(1, &tex);
    glBindTexture(GL_TEXTURE_CUBE_MAP, tex);

    for (int i = 0; i < CUBE_FACE_COUNT; ++i)
    {
        unsigned char* data = texture->data + texture->image_info[i].offset;
        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, format, texture->width, texture->height, 0, internalFormat, GL_UNSIGNED_BYTE, data);
    }

    glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

    texture->pbo = tex;
}
---


@s SDL Windowing

--- main loop
int g_windowWidth = 800;
int g_windowHeight = 600;

int main(int argc, const char * argv[])
{
    if (SDL_Init(SDL_INIT_VIDEO) == -1)
    {
        printf("failed to init SDL\n");
        return 1;
    }
    
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
     
    SDL_Window* window = NULL;
    SDL_GLContext* context = NULL;
    
    window = SDL_CreateWindow("Spherical Harmonics",
                              SDL_WINDOWPOS_CENTERED,
                              SDL_WINDOWPOS_CENTERED,
                              g_windowWidth,
                              g_windowHeight,
                              SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
    
    /* Create our opengl context and attach it to our window */
    context = SDL_GL_CreateContext(window);
    
    if (!window || !context)
    {
        printf("failed to create window and context\n");
        return 1;
    }
    
    SDL_GL_SetSwapInterval(1);   
    glViewport(0, 0, g_windowWidth, g_windowHeight);

    render_init(); 
     
    int quit = 0;
    int dragging = 0;

    int previous_mouse_x;
    int previous_mouse_y;
    
    while (!quit)
    {
        int x, y;
        SDL_GetMouseState(&x, &y);
        
        SDL_Event e;
        while (SDL_PollEvent(&e))
        {
            switch (e.type)
            {
                case SDL_QUIT:
                    quit = 1;
                    break;
                case SDL_MOUSEBUTTONDOWN:
                    dragging = 1;
                    previous_mouse_x = x;
                    previous_mouse_y = y;
                    break;
                case SDL_MOUSEBUTTONUP:
                    dragging = 0;
                    break;
           }
        }

        int dx = 0;
        int dy = 0;

        if (dragging)
        {
            dx = x - previous_mouse_x;
            dy = y - previous_mouse_y;

            previous_mouse_x = x;
            previous_mouse_y = y;
        }

        render_frame(dx, dy);
        SDL_GL_SwapWindow(window); 
    }
    
    SDL_GL_DeleteContext(context);
    
    return 0;
}
---

--- render.c --- noWeave

#include <stdio.h>
#include <stdlib.h>
#include <OpenGL/gl3.h>
#include "mesh.h"

@{vertex shader}
@{fragment shader}

@{compile shaders}
@{upload meshes}
@{upload cubemaps}

@{scene struct}

Scene scene;

@{render setup}
@{render a frame}
---

--- main.c --- noWeave
#include <SDL2/SDL.h>

@{render functions}
@{main loop}
---
